
import { supabase } from "@/integrations/supabase/client";
import { Holiday, HolidayFormData, HolidayType, BlockingType } from "@/types/holiday";

export async function fetchHolidays(): Promise<Holiday[]> {
  try {
    const { data, error } = await supabase
      .from('holidays')
      .select('*')
      .order('date', { ascending: true });
    
    if (error) throw error;
    
    // Transform do formato Supabase para o formato da aplicação
    return data.map(item => ({
      id: item.id,
      date: item.date,
      name: item.name,
      type: item.type as HolidayType,
      description: item.description || undefined,
      isActive: item.is_active,
      blockingType: item.blocking_type as BlockingType || 'full_day',
      customStartTime: item.custom_start_time || undefined,
      customEndTime: item.custom_end_time || undefined,
      autoGenerated: item.auto_generated || false,
      createdAt: item.created_at,
      updatedAt: item.updated_at
    }));
  } catch (error) {
    console.error('Erro ao buscar feriados:', error);
    throw error;
  }
}

export async function fetchHolidayById(id: string): Promise<Holiday | null> {
  try {
    const { data, error } = await supabase
      .from('holidays')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) throw error;
    if (!data) return null;
    
    return {
      id: data.id,
      date: data.date,
      name: data.name,
      type: data.type as HolidayType,
      description: data.description || undefined,
      isActive: data.is_active,
      blockingType: data.blocking_type as BlockingType || 'full_day',
      customStartTime: data.custom_start_time || undefined,
      customEndTime: data.custom_end_time || undefined,
      autoGenerated: data.auto_generated || false,
      createdAt: data.created_at,
      updatedAt: data.updated_at
    };
  } catch (error) {
    console.error('Erro ao buscar feriado:', error);
    throw error;
  }
}

export async function createHoliday(holidayData: HolidayFormData): Promise<Holiday> {
  try {
    const { date, name, type, description, isActive, blockingType } = holidayData;
    
    // Preparando o objeto para inserção
    const insertData: any = {
      date: date.toISOString().split('T')[0], // Formata como YYYY-MM-DD
      name,
      type,
      description,
      is_active: isActive,
      blocking_type: blockingType || 'full_day',
      auto_generated: false
    };
    
    // Adicionando campos customStartTime e customEndTime apenas se blockingType for 'custom'
    if (blockingType === 'custom') {
      insertData.custom_start_time = holidayData.customStartTime;
      insertData.custom_end_time = holidayData.customEndTime;
    }
    
    const { data, error } = await supabase
      .from('holidays')
      .insert(insertData)
      .select()
      .single();
    
    if (error) throw error;
    
    return {
      id: data.id,
      date: data.date,
      name: data.name,
      type: data.type as HolidayType,
      description: data.description || undefined,
      isActive: data.is_active,
      blockingType: data.blocking_type as BlockingType,
      customStartTime: data.custom_start_time || undefined,
      customEndTime: data.custom_end_time || undefined,
      autoGenerated: data.auto_generated || false,
      createdAt: data.created_at,
      updatedAt: data.updated_at
    };
  } catch (error) {
    console.error('Erro ao criar feriado:', error);
    throw error;
  }
}

export async function updateHoliday(id: string, holidayData: HolidayFormData): Promise<Holiday> {
  try {
    const { date, name, type, description, isActive, blockingType } = holidayData;
    
    // Preparando o objeto para atualização
    const updateData: any = {
      date: date.toISOString().split('T')[0], // Formata como YYYY-MM-DD
      name,
      type,
      description,
      is_active: isActive,
      blocking_type: blockingType || 'full_day',
      updated_at: new Date().toISOString()
    };
    
    // Se não for bloquio personalizado, limpa os campos de horário
    if (blockingType === 'custom') {
      updateData.custom_start_time = holidayData.customStartTime;
      updateData.custom_end_time = holidayData.customEndTime;
    } else {
      updateData.custom_start_time = null;
      updateData.custom_end_time = null;
    }
    
    const { data, error } = await supabase
      .from('holidays')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;
    
    return {
      id: data.id,
      date: data.date,
      name: data.name,
      type: data.type as HolidayType,
      description: data.description || undefined,
      isActive: data.is_active,
      blockingType: data.blocking_type as BlockingType,
      customStartTime: data.custom_start_time || undefined,
      customEndTime: data.custom_end_time || undefined,
      autoGenerated: data.auto_generated || false,
      createdAt: data.created_at,
      updatedAt: data.updated_at
    };
  } catch (error) {
    console.error('Erro ao atualizar feriado:', error);
    throw error;
  }
}

export async function deleteHoliday(id: string): Promise<void> {
  try {
    const { error } = await supabase
      .from('holidays')
      .delete()
      .eq('id', id);
    
    if (error) throw error;
  } catch (error) {
    console.error('Erro ao excluir feriado:', error);
    throw error;
  }
}

export async function importHolidays(year: number): Promise<any> {
  try {
    const { data, error } = await supabase.functions.invoke("fetch-holidays", {
      body: { year }
    });
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Erro ao importar feriados:', error);
    throw error;
  }
}
